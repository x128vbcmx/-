# 一份文档入门结绳
> 编辑作者:RedemptionCQFC
> 编辑时间:2023年7月19号
> 结绳版本:tiecode4.1.7
### 1.结绳简介
##### 1.1.结绳是什么？结绳中文是什么？
##### 1.2.结绳是谁开发的？
##### 1.3.结绳的官方网站在哪？官方群呢？
##### 1.4.在官方群时，我应该注意什么？
### 2.结绳使用
##### 2.1.创建工程
##### 2.2.导入工程
##### 2.3.安装插件
##### 2.4.管理文件
##### 2.5.安装绳包
##### 2.6.部署绳包
##### 2.7.顶项操作
##### 2.8.右上菜单
##### 2.9.编辑操作
##### 2.10.项目操作
##### 2.11.小工具
### 3.结绳语法
##### 3.1.变量与常量
##### 3.2.如果语句
##### 3.3.假如语句
##### 3.4.循环语句
##### 3.5.方法
##### 3.6.事件
##### 3.7.类
##### 3.8.属性读与属性写
##### 3.9.定义事件
### 4.结绳注解
##### 4.1.隐藏
##### 4.2.静态
##### 4.3.调试
##### 4.4.禁止调用
##### 4.5.禁止继承
##### 4.6.废弃使用(文本)
##### 4.7.属性需求.方法名(值)
##### 4.8.运算符重载
##### 4.9外部Java文件(文本)
##### 4.10.全局基础类
##### 4.11.主题配置...
##### 4.12.全局主题(文本)
##### 4.13.窗口主题(文本)
##### 4.14.后缀代码(文本)
##### 4.15.前缀代码
##### 4.16.嵌入式代码
##### 4.17.国际化
##### 4.18.布局配置(文本)
##### 4.19.禁止创建对象
##### 4.20.外部依赖库(文本)
##### 4.21.外部动态库(文本)
##### 4.22.虚拟事件
##### 4.23.输出名(文本)
##### 4.24.指代类(文本)
##### 4.25.全局应用
##### 4.26.强制输出
##### 4.27.导入Java(文本)
##### 4.28.虚拟方法
##### 4.29.附加资源(文本)
##### 4.30.安卓资源...
##### 4.31.附加清单...
##### 4.32.编译时处理参数
##### 4.33.附加可变清单...
##### 4.34.附加权限(文本)
##### 4.35.全局类
##### 4.36.异步方法
##### 4.37.需求值类型(类)
##### 4.38.常量类型(类)
##### 4.39.匹配文件(文本)
##### 4.40.值输出规则(文本)
##### 4.41.外部基础类(文本)
##### 4.42.Native构建
##### 4.43.软件配置...
##### 4.44.外部源文件(文本)
##### 4.45.引入头文件(文本)
### 5.结绳特性
##### 5.1.基本类型
##### 5.2.运算符
##### 5.3.显式转换
##### 5.4.数组
### 6.专有名词名单
##### 6.1.空对象/空(null)
##### 6.2.面向对象设计(object-oriented programming/OOP)
### 7.常见异常分析
##### 7.1.空指针异常(NullPointerException)
##### 7.2.索引越界异常(IndexOutOfBoundsException)
##### 7.3.类型转换异常(ClassCastException)
### 8.常见问题解决
##### 8.1.安卓环境获取问题
### 9.通用数据格式
##### 9.1.JSON
##### 9.2.XML
##### 9.3.HTML
##### 9.4.CSS
##### 9.5.JavaScript
## 1.结绳简介
### 1.1.结绳是什么？结绳中文是什么？
**结绳**是一款编程软件，你可以在**结绳**里面使用**结绳中文**(**TieCode**)**编程语言**开发程序，也就是说，**结绳**是一个**应用软件**，而**结绳中文**是一个**编程语言**。
### 1.2.结绳是谁开发的？
**结绳**由**结绳团队**开发，**结绳团队**于**2019**年成立，团队由最初的4人到6人再到18人，在**结绳**4.0.0版本以前，**结绳中文**的英文名叫做**S5droid**，4.0.0以后改为**TieCode**，同时，**结绳开发团队**更名为**结绳项目团队**。
### 1.3.结绳的官方网站在哪？官方群呢？
**结绳**的官方网站是==http://www.tiecode.cn/==，结绳的官方群有两个，一个为大群(编程技术讨论群)==938828067==，一个为小群(编程自由讨论群)==1074469442==。
### 1.4.在官方群时，我应该注意什么？
在大群时，请尽量不要讨论其他编程语言，以及其他非编程有关话题；小群可以讨论其他话题与程语言。并且，低于结绳4.0.0版本的问题不再接受，同时禁止交谈外挂/病毒/锁机等**禁忌工程**，以及禁止推送广告链接等。QQ官方和国家明文规定的非法行为也是不被允许的。
## 2.结绳使用
### 2.1.创建工程
打开结绳，右下角红色圆形+号按钮，点击即可创建工程，下面是对工程的介绍。
[工程类型]表示即将创建的工程类型。
[工程模板]这里是结绳为你预先准备的工程模板。
[工程名称]工程在结绳中显示的名称。
[软件名称]打包后安装到你的手机上的应用名称。
[软件包名]应用软件的身份证，至少含有一个小数点，且没有特殊字符，如果输入中文，结绳会自动把中文转为拼音。
### 2.2.导入工程
打开结绳，左下角有四个红色按钮，点最左边的按钮，选择**导入工程**，然后再选择工程备份路径即可。
### 2.3.安装插件
打开结绳，左下角有四个红色按钮，点最左边的按钮，选择**安装插件**，然后再选择插件文件路径即可。
### 2.4.管理文件
打开结绳，打开你的工程，左上方有个**三**，点这个**三**，就可以打开工程文件管理界面了，长按文件夹夹或文件即可操作。
### 2.5.安装绳包
打开结绳，打开你的工程，右上角有三个点，点开它，选择**安装绳包**，然后再选择绳包文件路径即可。
### 2.6.部署绳包
打开结绳，打开你的工程，左上方有个**三**，点这个**三**，就可以打开工程文件管理界面了，然后长按**绳包**文件夹，选择**管理绳包**，然后勾选你想要部署的绳包即可。
### 2.7.顶项操作
打开结绳，打开你的工程，上面有几个小图标，现在介绍一下它们的作用。
[铅笔/眼睛-读写切换]图标为铅笔时，表示当前为写模式，图标为眼睛时，表示当前为读模式。
[三角形-运行按钮]单击即可编译打包你的工程，长按可选择打包类型，默认为调试运行。
[左箭头-撤回]表示撤回你刚才的操作
[右箭头-撤回]表示还原你刚才的操作
### 2.8.右上菜单
打开结绳，打开你的工程，右上角有三个点，点开它，这里有几个菜单，简单介绍一下。
[保存]保存当前工程代码
[日志]打开日志页
[git]打开git页
[安装绳包]见2.5
### 2.9.编辑操作
打开结绳，打开你的工程，右上角有三个点，点开它，再点开**编辑操作**，简单介绍一下。
[粘贴]将你的剪切板的内容粘贴到你光标的位置里。
[查找]打开查找功能，可以在当前代码里查找关键词。
[替换]和查找差不多，不过多了个替换关键词的功能。
[复制一行]复制光标当前行，然后粘贴到下一行。
[删除一行]删除本行代码。
[对齐代码]缩进难看时可以点一下，自动对齐缩进。
### 2.10.项目操作
打开结绳，打开你的工程，右上角有三个点，点开它，再点开**项目操作**，简单介绍一下。
[备份项目]会备份当前项目到结绳的backups目录里。
[分享源码]把项目分享给应用。
[修改信息]修改工程的信息
[清理缓存]结绳编译时会留下缓存，可以清理掉它来减少存储空间。
[正式打包]去除所有调试类，正式打包为一个独立的安装包。
[制作绳包]将当前工程打包为绳包，但是初始代码.t不会打包，绳包文件位于工程的build/lib里面。
[部署到设计器]没有用，一般用来免打包编译。
### 2.11.小工具
自己探索先，太多写不完。
## 3.结绳语法
### 3.1.变量与常量
**变量**是用来存储**数据**的一种**标识符**。可以将其看作是一个**容器**，用来存储各种各样的**值**。**变量**有不同的**类型**，例如**整数**、**小数**、**文本**等等。在程序执行过程中，**变量**的值可以被**更改**。**常量**是在程序中固定不变的**值**。与**变量**不同，**常量**在**定义**之后就无法修改。
变量的声明格式为:
```
变量 变量名称 为 类型
```
>有时候为了方便，可以把**为**替换为一个**冒号**(**:**)

可以在**声明变量**的同时为**变量赋值**:
```
变量 变量名称 为 类型 = 值
```
结绳会自动为**引用类型**的变量创建对象，但是如果类型后面带有?，结绳就不会自动创建对象，即该变量为空:
```
变量 变量名称 为 引用类型?
```
常量的声明和变量差不多:
```
常量 常量名称 为 类型 = 值
```
### 3.2.如果语句
如果语句用于根据某个条件是否为真来决定程序的执行路径。可以将其理解为一种选择结构。根据条件的不同结果，程序会选择不同的路径执行。
如果语句分为3种，分别为；
**(普通)如果语句**:
```
如果 逻辑表达式 则
    //当逻辑表达式为真时执行
结束 如果
```
**如果-否则语句**:
```
如果 逻辑表达式 则
    //当逻辑表达式为真时执行
否则
    //当逻辑表达式为假时执行
结束 如果
```
**如果-否则-否则语句**:
```
如果 逻辑表达式1 则
    //当逻辑表达式1为真时执行
否则 逻辑表达式2
    /*
    当逻辑表达式1为假
    但是逻辑表达式2为真时执行
    */
...
否则
   //所有逻辑表达式均为假时执行
结束 如果
```
### 3.3.假如语句
假如语句是一种选择结构，用于根据一个变量的不同值来选择不同的执行路径，可以将其理解为一种多重选择的语句。
假如语句分为2种，分别为；
**(普通)假如语句**:
```
假如 变量名
    是 常量情景1
       //命中情景1时执行
    是 常量情景2
       //命中情景2时执行
    是 常量情景3
       //命中情景3时执行
结束 假如
```
**假如-否则语句**:
```
假如 变量名
    是 常量情景1
       //命中情景1时执行
    是 常量情景2
       //命中情景2时执行
    是 常量情景3
       //命中情景3时执行
    否则
       //没有命中情景时执行
结束 假如
```
### 3.4.循环语句
**循环语句**的作用是重复执行一段**代码块**，直到达到某个**条件**为止。它可以帮助程序员节省时间和精力，避免重复编写相同的代码。
**循环语句**的主要目的是处理需要重复执行的**任务**，例如对**数组**或**列表**中的每个**元素**进行操作，或在遇到满足一定条件的情况下执行特定的代码。通过使用循环语句，可以在不同的情况下重复执行相同的代码，而不需要手动**复制**和**粘贴**代码块。
**循环语句**分为三种；
**判断循环语句**:
```
循环(逻辑表达式)
    /*
    循环代码块
    每执行完毕一次
    就判断逻辑表达式
    如果为真则继续循环
    如果为假则停止循环
    */
结束 循环
```
**变量循环语句**:
```
循环(变量名,初始值,终止值,步值)
    /*
    循环代码块
    变量会首先赋值为初始值
    当初始值超过终止值时
    停止循环
    步值代表每次循环增进的值
    */
结束 循环
```
**遍历循环语句**:
```
循环(遍历从对象->遍历至变量)
    /*
    循环代码块
    遍历从对象必须可遍历
    每一次循环都会
    把遍历从对象的元素
    遍历到遍历至变量上
    */
结束 循环
```
同时，为了更好的操控循环语句，还有两个特殊的语句，**退出循环**表示终止当前循环，**跳过循环**表示跳过当前次循环，到下一次循环。
```
循环()
    //循环代码块
    跳过循环
结束 循环
```
```
循环()
    //循环代码块
    退出循环
结束 循环
```
### 3.5.方法
**方法**指的是一段可重复使用的**代码块**，它接收输入**参数**、执行特定的**任务**，并返回一个**返回值**。
**方法**声明格式为:
```
方法 方法名()
    //方法体
结束 方法
```
带**返回值**是这样的:
```
方法 方法名() 为 返回类型
    //方法体
    返回 返回值
结束 方法
```
带**参数**是这样的:
>方法可以有多个参数，比如(参数1 为 类型,参数2 为 类型)
```
方法 方法名(参数1 为 类型)
    //方法体
结束 方法
```
调用**方法**的**格式**是这样的:
```
方法名(参数1,参数2)
```
### 3.6.事件
**事件**与**方法**差不多，但是事件一般用来**被动**执行，而方法用来**主动**执行。
**事件**的声明格式为:
```
事件 监听对象:监听事件()
    //触发事件时执行
结束 事件
```
**事件**和**方法**一样，某些**事件**会带有**参数**和**返回值**。
```
事件 监听对象:监听事件(参数 为 类型)
结束 事件
事件 监听对象:监听事件() 为 类型
结束 事件
```
### 3.7.类
**类**是一种**数据结构**，用于封装**属性**与**行为**。**类**可以被视为**对象**的蓝图或模板，描述了**对象**的特性和行为。**类**是**面向对象设计**的基本概念之一。
**类**由**属性**和**行为**组成。**属性**是**类**的**变量**，描述了**对象**的状态；**方法**定义了**类**的**行为**，描述了**对象**的**行为**和**操作**。
**类**可以通过**实例化**创建**对象**，**对象**是**类**的一个**实例**。**对象**具有**类**定义的**属性**和**行为**。每个**对象**都可以独立地**访问**和**修改**其**属性**，调用其方法。
类的声明格式分为2种；
**隐式继承**:
>隐式继承会自动指定父类，父类一般为当前平台的@全局基础类
```
类 类名
    //类体
结束 类
```
**显式继承**:
```
类 类名 : 父类名
    //类体
结束 类
```
以上的声明格式均为声明**普通类**，在**结绳中文**中还有一种特殊的类声明格式：**模板类**。
**模板类**允许在编写代码时使用一种通用**类型**，而不是具体的**类型**。**模板类**提供了代码的灵活性和可重用性，可以在不同的数据**类型**上使用相同的代码逻辑。
**模板类**仅提供一个**类模板**，而不能直接使用，需要一个类来继承**模板类**并指定其**模板类型**，我们称这个类叫做**实现类**。
>模板类的子类也可以是模板类

**模板类的声明格式为**:
```
类 模板类名<模板类型1>
    //模板类体
结束 类
```
**实现类的声明格式为**:
>一般来说，实现类体是空的
```
类 实现类名 : 模板类名<指定类型>
结束 类
```
### 3.8.属性读与属性写
**属性读**与**属性写**是两种特殊的**方法**，它们的作用更加纯粹，只是用来体现**读取**和**写入**两个动作，并且它们的声明格式十分严格。
**属性读的声明格式为**:
>属性读没有参数，且必须有返回值
```
属性读 名称() 为 类型
    //方法体
结束 属性
```
**属性写的声明格式为**:
>属性写有且只有一个参数，且没有返回值
```
属性写 名称(参数 为 类型)
    //方法体
结束 属性
```
### 3.9.定义事件
**定义事件**用来为类实例定义一个**事件监听器**，而**事件监听器**可以通过**事件**语句监听。
```
定义事件 事件名()
```
当然，**事件**可以有**参数**与**返回值**
```
定义事件 事件名(参数 为 类型) 为 类型
```
这时，你可以把**定义事件**当做一个**方法**调用，调用**定义事件**就代表触发这个**事件**。
## 4.结绳注解
### 4.1.隐藏
用于指定**成员**为**私有的**，在类外无法直接**访问**该**成员**。
### 4.2.静态
用于指定**成员**为**静态的**，**静态成员**属于**类**本身而不是通过**类实例化**出来的**对象**，**静态成员**以"类名.成员名"调用。
### 4.3.调试
用于指定该**方法**为调试**方法**，在正式打包后去除该**方法**。
### 4.4.禁止调用
用于指定该**方法**在任何地点都不得调用。
### 4.5.废弃使用(文本)
用于指定该**方法**已经过时，废弃了，如果调用就会在日志输出警告文本。
### 4.6.禁止继承
指定一个类被禁止继承，即此类不能有子类，不能成为任何类的父类。
### 4.7.属性需求.方法名(值)
只能用在定义事件上面，后面XXX表示一个方法名，用于设定先触发的方法。
### 4.8.运算符重载
指定一个方法重载了运算符，可重载的运算符有= ? + - * / % == != < > <= >= [] []=，使用运算符时会调用运算符重载的方法来处理。
### 4.9.外部Java文件(文本)
在类上标注，打包时附加该Java文件进行编译。
### 4.10.全局基础类
设定该类为隐式继承的父类，一般来说，此类被**对象**类占用，一般人用不了。
### 4.11.主题配置
设置该变量的主题配置，同时该变量必须是**主题资源**类，其下有多个副分支，比如@**主题配置.主题类型()**。
### 4.12.全局主题(文本)
设置整个应用的主题，参数必须是一个变量名，且变量类型必须是**主题资源**。
### 4.13.窗口主题(文本)
与**全局主题**相反，窗口主题是设置本窗口的主题。
### 4.14.后缀代码(文本)
在类或者方法后面添加一段代码，一般是原生用途，普通使用结绳中文用不到，比如在类后面添加**implements a**。
### 4.15.前缀代码(文本)
和后缀代码差不多，不过是在前面添加，一般用来加修饰符，比如前缀**abstract**
### 4.16.嵌入式代码
指定该方法为嵌入式代码，该方法在打包时会去掉，并且把使用用到该方法的地方嵌入进去方法的代码，同时方法参数允许使用**变体型**，**变体型**表示你填什么都可以，甚至是**类名**，注：嵌入式代码内必须全是code代码，否则报错。
### 4.17.国际化
指定该变量在相应的语言环境下的内容，并且该变量的类型必须是**文本资源**，国际化有几个子注解，比如@**国际化.en.SU(文本)**
### 4.18.布局配置(文本)
此注解由布局设计器自动生成，请勿随意删除修改。
### 4.19.禁止创建对象
表示该类不能由结绳自动创建对象，需要手动创建或者不需要创建。
### 4.20.外部依赖库(文本)
参数为路径，表示导入一个jar/aar包，打包时会带上它。
### 4.21.外部动态库(文本)
和外部依赖库差不多，不过是导入so包。
### 4.22.虚拟事件
表示该方法为虚拟事件，该方法禁止有任何代码，此类的子类可以监听自己继承而来的的虚拟事件。
### 4.23.输出名(文本)
结绳会自动混淆类名/方法名/变量名，可以使用该注解指定最终输出名。
### 4.24.指代类(文本)
指定一个类是指代一个原生类的，参数为**完整类名**，即被指代的原生类。
### 4.25.全局应用
指定该类为本应用的安卓应用，此类必须继承**应用**类。
### 4.26.强制输出
无论是否用到该类/方法/变量，结绳都会为其编译。
### 4.27.导入Java(文本)
导入一个Java包类，一般用于原生封装开发，相当于**import xxx.xx**。
### 4.28.虚拟方法
设置该方法为虚拟方法，虚拟方法可以被子类覆写。
### 4.29.附加资源(文本)
附加一个资源文件，将其打包到安装包的assets文件夹里。
### 4.30.安卓资源
该注解有多个子注解，比如@**安卓资源.动画(文本)**，与附加资源不同的是，该注解会打包到res文件夹。
### 4.31.附加清单
该注解下有多个子注解，比如@**附加清单.属性(文本)**，用于为安卓清单附加内容。
### 4.32.编译时处理参数
表示注解可以引用方法的参数。
### 4.33.附加可变清单
和附加清单差不多，不过可以通过改变方法的参数来改变清单的内容。
### 4.34.附加权限(文本)
表示附加一个权限，参数为权限名。
### 4.35.全局类
表示该类的静态成员不需要通过**类名.成员名**引用，可以直接**成员名**。
### 4.36.异步方法
表示此方法为异步方法，异步方法必须有一个**等待过程**，可以使用**等待**关键词来声明**等待过程**，**等待 方法名()**，**方法名()**此时在新线程执行，执行完成后再执行**非等待部分**，**非等待部分**在主线程执行，注：异步方法不能有返回值。
### 4.37.需求值类型(类)
需求值类型表示当前类创建所需的值，参数为任意**基本类型**或**文件路径**或**颜色值**。
### 4.38.常量类型(类)
表示当前类实际上指代的基本类型，参数只能为基本类型。
### 4.39.匹配文件(文本)
该注解附加前需要先附加@**需求值类型(文件路径)**，该注解表示创建本类对象所需的文件格式，参数为正则表达式文本，不符合则报错。
### 4.40.值输出规则(文本)
用于指定本类对象的值输出路径，一般是安装包内资源路径。
### 4.41.外部基础类(文本)
表示该类继承原生类，参数为被继承的原生类的完整类名。
### 4.42.Native构建
表示该方法的方法体在外部动态库定义，而不是在dex中定义。
### 4.43.软件配置
用于指定软件的配置，该注解下有多个子注解，如@**软件配置.软件名称(文本)**
### 4.44.外部源文件(文本)
Linux工程专属注解，用于附加外部原生的.h/.cpp参与编译。
### 4.45.引入头文件(文本)
Linux工程专属注解，用于在当前文件引入其他文件。
## 5.结绳特性
### 5.1.基本类型
结绳的**基本类型**共有8个，它们分别是**整数**、**长整数**、**字节**、**小数**、**单精度小数**、**逻辑型**、**字符**，部分看起来是**基本类型**实际上是**引用类型**的有很多，比如**文本**。
### 5.2.运算符
运算符分为很多种，按操作数可分为**一元运算符**、**二元运算符**、**三元运算符**，按功能分为**数学运算符**、**逻辑运算符**、**赋值运算符**。
a + b(**二元数学运算符**,ab均为**加数**,返回**和**)
a - b(**二元数学运算符**,a为**被减数**,b为**减数**,返回**差**)
a / b(**二元数学运算符**,a为**被除数**,b为**除数**,返回**商**)
a * b(**二元数学运算符**,ab均为**乘数**,返回**积**)
a % b(**二元数学运算符**,a为**被除数**,b为**除数**,返回**余数**)
a == b(**二元逻辑运算符**,ab均为**值**,返回**是否相同**)
a != b(**二元逻辑运算符**,ab均为**值**,返回**是否不同**)
a < b(**二元逻辑运算符**,ab均为**数字**,返回**a是否小于b**)
a > b(**二元逻辑运算符**,ab均为**数字**,返回**a是否大于b**)
a <= b(**二元逻辑运算符**,ab均为**数字**,返回**a是否小于或等于b**)
a >= b(**二元逻辑运算符**,ab均为**数字**,返回**a是否大于或等于b**)a ? b(**二元逻辑运算符**,ab均为**文本**,返回**a是否包含b**)
a < b < c(**三元逻辑运算符**,abc均为**数字**,返回**a是否小于b并且b是否小于c**)
a > b > c(**三元逻辑运算符**,abc均为**数字**,返回**a是否大于b并且b是否大于c**)
a <= b <= c(**三元逻辑运算符**,abc均为**数字**,返回**a是否小于或等于b并且b是否小于或等于c**)
a => b => c(**三元逻辑运算符**,abc均为**数字**,返回**a是否大于或等于b并且b是否大于或等于c**)
++a(**一元赋值运算符**,a为**变量**,类型为**任意数学类型**，使a自己+1)
--a(**一元赋值运算符**,a为**变量**,类型为**任意数学类型**，使a自己-1)a = b(**二元赋值运算符**,a为**变量**,b为**值**，使a等于b)
a <=> b(**二元赋值运算符**,ab均为**变量**，使ab互换它们的值)
### 5.3.显式转换
**基本类型**的**显式转换**与**引用类型**的**显式转换**是两套不同的规则。
结绳的**显式转换**语法是：
```
(值:欲转换类)
```
**[基本类型]**基本类型的显式转换可以让精度低的值安全转为精度高的值，精度高的值转换为精度低的值的时候有可能会损失精度。
**[引用类型]**引用类型的显式转换可以让子类对象安全转为父类对象，父类对象在转换为子类对象时可能会报错，只有父类对象本身是一个被转换的子类对象才能重新转换为子类对象。
### 5.4.数组
**数组**和**集合**类似，都是用于存储**对象**的，只不过**集合**的最大容量是自适应的，而**数组**的最大容量是固定的。
数组的声明格式为：
```
变量 数组名 为 元素类型[]
```
其中，**元素类型**代表**数组**的**元素**的**类型**，但是此时，这个**数组**为**空**，还没有赋值。
**数组**声明带赋值分为两种：
**[静态]**提前指定**数组**元素，根据元素数量自适应**数组**长度。
**[动态]**直接声明**数组**的长度，但是不会填充**元素**，即**元素**为**空**或为**基本类型默认值**。
```
变量 静态数组 为 元素类型[] = {
元素1,元素2,元素3}
变量 动态数组 为 元素类型[3]
```
**数组**有两个独特的**运算符**：
```
/*注:数组的索引以0开始*/
//通过[]下标访问数组的元素
数组名[0]
//通过[]=下标等于来为数组元素赋值
数组名[0]=114514
```
## 6.专有名词名单
### 6.1.空对象/空(null)
null是一个特殊的值，它表示某个变量或引用不引用任何对象或值。可以将null视为一个空的或不存在的引用。
null通常用于以下情况：
1. 当对象还没有被实例化时，可以将对象引用设置为null。
2. 当对象不再需要时，可以将其引用设置为null，这样垃圾收集器可以回收该对象占用的内存空间。需要注意的是，null是一个特殊的值，是一种“无”的状态，并不等同于空文本、空数组或空指针。而且，在访问null引用的方法或属性时，会抛出NullPointerException异常。因此，在编写代码时，需要小心处理null值，避免出现空指针异常，并使用相应的条件判断来处理null引用。
### 6.2.面向对象编程(object-oriented programming/OOP)
面向对象编程是一种编程范式，它将程序设计问题视作对象之间的相互作用。在面向对象编程中，程序被组织成对象，每个对象都有自己的状态和行为，并能通过与其他对象的交互来实现任务的完成。
面向对象编程的核心概念包括封装、继承和多态。
封装（Encapsulation）是指将特定数据和对这些数据的操作捆绑在一起，形成一个对象。对象可以暴露一些公共方法来允许其他对象访问和操作其内部状态，同时隐藏不必要的细节和实现细节。
继承（Inheritance）允许创建一个新的类，这个类继承了现有的类的特性和行为，并且可以添加或修改一些新的特性和行为。继承提供了代码重用的机制，并且使得代码更加可维护和可扩展。
多态（Polymorphism）指的是通过一个类的对象调用其父类的方法时，实际执行的是子类覆盖了父类的方法的实现。多态提供了一种灵活的方式来处理不同类型的对象，使得代码可以根据上下文动态地调用不同类的方法。面向对象编程的优点包括代码的重用性、可维护性和可扩展性。通过将大型程序划分为多个小的、可重用的对象，可以更容易地理解和修改程序的不同部分。面向对象编程还可以提高代码的模块化程度，使得程序开发更加高效和可靠。
## 7.常见异常分析
### 7.1.空指针异常(NullPointerException)
NullPointerException（空指针异常）是一种常见的运行时异常，在代码执行过程中引用了一个空（null）的对象或者引用。
当程序尝试通过一个null引用来调用方法、访问成员变量或者执行其他与对象相关的操作时，就会抛出NullPointerException。这意味着当前操作需要一个非空对象，但实际引用为空，无法执行操作。NullPointerException通常由以下情况引起：
1. 对象引用未经初始化，即没有被赋予一个有效的对象。
2. 引用被显式地设置为null。
3. 引用通过调用方法或者访问成员变量时，被传递给一个期望非空对象的方法或者操作。为了避免NullPointerException的发生，应该在使用对象之前，合理进行非空判断。可以使用条件语句（如if语句）来判断引用是否为null，并根据需要进行相应的处理（如抛出异常、返回默认值等）。此外，良好的编程实践也包括在设计和编写代码时避免出现null引用的情况，例如使用默认值或者空对象来代替null引用。
### 7.2.索引越界异常(IndexOutOfBoundsException)
它是一种常见的运行时异常，在访问数组、集合或字符串等数据结构时使用了超出其有效索引范围的索引值。
当程序中使用一个超出有效索引范围的索引值来访问数组、集合或文本时，就会抛出索引越界异常。这意味着程序试图访问不存在的元素或者访问的范围超过了数据结构的有效范围。索引越界异常通常由以下情况引起：
1. 用一个小于0或大于等于数组、集合或文本长度的索引值进行访问。
2. 在使用索引时，没有正确处理边界条件，导致超过了数据结构的有效范围。为了避免索引越界异常的发生，应该在使用索引之前，进行合理的索引范围检查。可以使用如果语句或循环语句来确保索引在有效范围内，并根据需要进行相应的处理（如抛出异常、返回默认值等）。同时，在编写循环时，需要小心处理索引的增加或减少操作，以确保在有效范围内。良好的编程实践包括使用合适的数据结构和正确处理索引范围，以及进行适当的错误处理，可以有效避免索引越界异常的发生。
### 7.3.类型转换异常(ClassCastException)
它是一种常见的运行时异常，表示试图将一个对象强制转换为不兼容的类类型。
对象之间的类型转换通常使用父类引用指向子类对象，或者将对象从一种类型转换为另一种类型。在进行类型转换时，如果对象的实际类型与目标类型不兼容，就会抛出类型转换异常。
类型转换异常通常发生在以下情况下：
1. 将一个对象强制转换为不是其父类的类型，即将一个不是该类型的对象赋值给一个类的引用变量。
2. 将一个对象转换为不兼容的接口类型。
3. 当试图将一个包含不兼容类型的集合转换为特定类型的数组时。
为了避免类型转换异常，应该在执行类型转换之前，先进行类型检查。可以使用**属于**关键字来判断对象的实际类型，并确保类型转换是合法的。此外，在进行类型转换时，还可以使用容错处理语句来捕获ClassCastException并进行相应的处理，如选择其他适合的类型转换方式或者抛出自定义异常。
## 8.常见问题解决
### 8.1.安卓环境获取问题
当你需要一个安卓环境对象时，你可以直接在**窗口**类中填**本对象**，因为**窗口**间接继承**安卓环境**，在**服务**中也同理，因为**服务**也继承**安卓环境**，在**组件容器**中可以使用**取安卓环境**()或者**取安卓窗口**()来获取安卓环境。
## 9.通用数据格式
### 9.1.JSON
JSON是JavaScript Object Notation(JS对象格式)的缩写，它是一种轻量级的数据交换格式。JSON格式以键值对的形式存储数据，可以表示简单的数据结构，比如数字、文本、逻辑等，也可以表示复杂的数据结构，比如数组和对象。JSON数据采用类似于JavaScript对象的语法，并且可以被多种编程语言解析和生成。它在Web开发中广泛应用于数据传输和存储，常用于前后端之间的数据交互。
JSON的语法非常简洁明了，以下是一些常见的JSON语法规则：
1. 键值对：数据由键和值组成，使用冒号:分隔，每对键值对之间使用逗号,分隔。键必须是一个字符串，值可以是文本、数字、逻辑、数组、对象或者空。
2. 对象：用花括号{}表示对象，对象中的键值对之间使用逗号,分隔。例如{ "name": "John",  "age": 25,  "isStudent": true}
3. 数组：用方括号[]表示数组，数组中的元素之间使用逗号,分隔。例如：["apple", "banana", "orange"]
4. 值：可以是文本(必须用双引号括起来)、数字、逻辑(true或false)、对象、数组或空。例如："Hello World"/42/true/null这些只是JSON语法的基本规则，JSON还支持嵌套、转义字符等特性。
>注：只看文档而不学是没有用的，它不能完全涵盖所有内容，没有自学能力的建议趁早改行。

